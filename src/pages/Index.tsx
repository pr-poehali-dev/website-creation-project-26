import React, { useState, useRef, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import VideoDisplay from '@/components/VideoDisplay';
import RecordingControls from '@/components/RecordingControls';
import QRModal from '@/components/QRModal';
import QRCode from '@/components/QRCode';

const Index = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [recordedVideo, setRecordedVideo] = useState<string | null>(null);
  const [recordingTime, setRecordingTime] = useState(0);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const [showQRModal, setShowQRModal] = useState(false);
  
  const videoRef = useRef<HTMLVideoElement>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const MAX_RECORDING_TIME = 300;

  useEffect(() => {
    return () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [stream]);

  const startCamera = async () => {
    try {
      const mediaStream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: { ideal: 480 },
          height: { ideal: 360 },
          frameRate: { ideal: 15 },
          facingMode: 'environment'
        }, 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 48000, // Telegram –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç 48kHz –¥–ª—è AAC
          channelCount: 2
        }
      });
      
      setStream(mediaStream);
      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream;
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', error);
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.');
    }
  };

  const startRecording = async () => {
    if (!stream) {
      try {
        const mediaStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 480 },
            height: { ideal: 360 },
            frameRate: { ideal: 15 },
            facingMode: 'environment'
          }, 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 48000, // Telegram –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç 48kHz –¥–ª—è AAC
            channelCount: 2
          }
        });
        
        setStream(mediaStream);
        if (videoRef.current) {
          videoRef.current.srcObject = mediaStream;
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
        startRecordingWithStream(mediaStream);
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', error);
        alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.');
        return;
      }
    } else {
      startRecordingWithStream(stream);
    }
  };

  const startRecordingWithStream = (mediaStream: MediaStream) => {
    setRecordedVideo(null);
    chunksRef.current = [];
    
    const audioTracks = mediaStream.getAudioTracks();
    const videoTracks = mediaStream.getVideoTracks();
    
    console.log('Audio tracks:', audioTracks.length);
    console.log('Video tracks:', videoTracks.length);
    
    audioTracks.forEach(track => {
      track.enabled = true;
      console.log('Audio track enabled:', track.enabled, 'ready state:', track.readyState);
    });
    
    let mediaRecorder;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è –≤—ã–±–æ—Ä–∞ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–µ–∫–∞
    const isAndroid = /Android/.test(navigator.userAgent);
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    
    try {
      // –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: Android Telegram –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç –∑–≤—É–∫ –¢–û–õ–¨–ö–û —Å AAC!
      if (isAndroid && MediaRecorder.isTypeSupported('video/mp4;codecs=h264,mp4a.40.2')) {
        // Android: –°—Ç—Ä–æ–≥–æ AAC-LC –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∑–≤—É–∫–∞ –≤ Telegram
        mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: 'video/mp4;codecs=h264,mp4a.40.2',
          audioBitsPerSecond: 128000, // –°—Ç–∞–Ω–¥–∞—Ä—Ç AAC –¥–ª—è Telegram
          videoBitsPerSecond: 1200000
        });
        console.log('‚úÖ Android: AAC-LC –∫–æ–¥–µ–∫ - –∑–≤—É–∫ –≤ Telegram –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å!');
      } else if (isAndroid && MediaRecorder.isTypeSupported('video/mp4;codecs=h264,aac')) {
        // Android: –û–±—â–∏–π AAC
        mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: 'video/mp4;codecs=h264,aac',
          audioBitsPerSecond: 128000,
          videoBitsPerSecond: 1200000
        });
        console.log('‚úÖ Android: AAC –∫–æ–¥–µ–∫ - –∑–≤—É–∫ –≤ Telegram –¥–æ–ª–∂–µ–Ω —Ä–∞–±–æ—Ç–∞—Ç—å');
      } else if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264,mp4a.40.2')) {
        // –î—Ä—É–≥–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: AAC-LC –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ
        mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: 'video/mp4;codecs=h264,mp4a.40.2',
          audioBitsPerSecond: 128000,
          videoBitsPerSecond: 1500000
        });
      } else if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264,aac')) {
        mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: 'video/mp4;codecs=h264,aac',
          audioBitsPerSecond: 128000,
          videoBitsPerSecond: 1500000
        });
      } else if (MediaRecorder.isTypeSupported('video/mp4')) {
        mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: 'video/mp4',
          audioBitsPerSecond: 128000,
          videoBitsPerSecond: 1500000
        });
      } else {
        // Fallback –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤
        mediaRecorder = new MediaRecorder(mediaStream, {
          audioBitsPerSecond: 128000,
          videoBitsPerSecond: 1500000
        });
      }
      
      console.log('üìπ MediaRecorder —Å–æ–∑–¥–∞–Ω:', mediaRecorder.mimeType);
      
      // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –¥–ª—è Android –±–µ–∑ AAC
      if (isAndroid && !mediaRecorder.mimeType.includes('mp4a.40') && !mediaRecorder.mimeType.includes('aac')) {
        console.warn('‚ö†Ô∏è Android: –ù–µ—Ç AAC –∫–æ–¥–µ–∫–∞ - –≤–æ–∑–º–æ–∂–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã —Å–æ –∑–≤—É–∫–æ–º –≤ Telegram!');
      }
      
    } catch (e) {
      console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è MediaRecorder:', e);
      mediaRecorder = new MediaRecorder(mediaStream);
    }
    
    mediaRecorderRef.current = mediaRecorder;
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        chunksRef.current.push(event.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      const mimeType = mediaRecorderRef.current?.mimeType || 'video/mp4';
      const blob = new Blob(chunksRef.current, { type: mimeType });
      const videoURL = URL.createObjectURL(blob);
      setRecordedVideo(videoURL);
    };
    
    mediaRecorder.start();
    setIsRecording(true);
    setRecordingTime(0);
    
    timerRef.current = setInterval(() => {
      setRecordingTime(prev => {
        if (prev >= MAX_RECORDING_TIME - 1) {
          stopRecording();
          return MAX_RECORDING_TIME;
        }
        return prev + 1;
      });
    }, 1000);
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
      
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    }
  };

  const shareVideo = async () => {
    if (!recordedVideo) {
      alert('–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –≤–∏–¥–µ–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏');
      return;
    }
    
    try {
      const response = await fetch(recordedVideo);
      const blob = await response.blob();
      const file = new File([blob], `video_${Date.now()}.mp4`, { type: blob.type });
      
      // –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
      const locationData = localStorage.getItem('userLocation');
      let locationText = '';
      if (locationData) {
        try {
          const location = JSON.parse(locationData);
          locationText = `\\nüìç ${location.latitude}, ${location.longitude}`;
        } catch (e) {
          console.error('–û—à–∏–±–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏:', e);
        }
      }
      
      const message = `üé• –ù–æ–≤—ã–π –ª–∏–¥ IMPERIA PROMO!\\nüìÖ ${new Date().toLocaleString()}${locationText}`;
      
      // –ü–æ–ø—Ä–æ–±—É–µ–º Web Share API –¥–ª—è –ø—Ä—è–º–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏
      if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            title: 'üé• –ù–æ–≤—ã–π –ª–∏–¥ IMPERIA PROMO',
            text: message,
            files: [file]
          });
          
          // –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É —É—Å–ø–µ—Ö–∞
          setTimeout(() => {
            window.location.href = '/success';
          }, 500);
          return;
          
        } catch (shareError) {
          console.log('Web Share –æ—Ç–º–µ–Ω–µ–Ω –∏–ª–∏ –Ω–µ —É–¥–∞–ª—Å—è:', shareError.name);
          if (shareError.name === 'AbortError') {
            return; // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–º–µ–Ω–∏–ª
          }
        }
      }
      
      // Fallback: –æ—Ç–∫—Ä—ã—Ç–∏–µ Telegram —Å —Ç–µ–∫—Å—Ç–æ–º + –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
      const encodedMessage = encodeURIComponent(message);
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      
      if (isMobile) {
        // –ú–æ–±–∏–ª—å–Ω—ã–µ: –æ—Ç–∫—Ä—ã–≤–∞–µ–º Telegram
        window.location.href = `tg://msg?text=${encodedMessage}`;
        
        // Fallback —á–µ—Ä–µ–∑ –≤–µ–±
        setTimeout(() => {
          window.open(`https://t.me/share/url?url=${encodedMessage}`, '_blank');
        }, 1000);
        
        alert('üì± –û—Ç–∫—Ä–æ–µ—Ç—Å—è Telegram\n\n1. –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—è\n2. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–∏—è (üìé)\n3. –í—ã–±–µ—Ä–∏—Ç–µ –≤–∏–¥–µ–æ –∏–∑ –≥–∞–ª–µ—Ä–µ–∏\n4. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ');
      } else {
        // Desktop: Telegram Web
        window.open(`https://web.telegram.org/a/#?text=${encodedMessage}`, '_blank');
        alert('üíª –û—Ç–∫—Ä–æ–µ—Ç—Å—è Telegram Web\n\n1. –í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç\n2. –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –≤–∏–¥–µ–æ—Ñ–∞–π–ª –≤ –æ–∫–Ω–æ —á–∞—Ç–∞\n3. –î–æ–±–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–∞–∫ –ø–æ–¥–ø–∏—Å—å');
      }
      
      setTimeout(() => {
        window.location.href = '/success';
      }, 2000);
      
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:', error);
      alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤–∏–¥–µ–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.');
    }
  };

  const handleRetake = () => {
    setRecordedVideo(null);
    setRecordingTime(0);
    setIsRecording(false);
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      setStream(null);
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="min-h-screen bg-gray-50 p-4">
      <div className="max-w-6xl mx-auto">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 h-screen lg:h-auto">
          
          <QRCode onShowModal={() => setShowQRModal(true)} />

          <Card className="p-8 flex flex-col bg-white shadow-lg rounded-2xl">
            <div className="flex-1 flex flex-col">
              
              <VideoDisplay 
                recordedVideo={recordedVideo}
                stream={stream}
                videoRef={videoRef}
                isRecording={isRecording}
                recordingTime={recordingTime}
                maxRecordingTime={MAX_RECORDING_TIME}
                formatTime={formatTime}
              />

              <RecordingControls
                recordedVideo={recordedVideo}
                isRecording={isRecording}
                recordingTime={recordingTime}
                stream={stream}
                onStartRecording={startRecording}
                onStopRecording={stopRecording}
                onRetake={handleRetake}
                onShareVideo={shareVideo}
                formatTime={formatTime}
              />
              
            </div>
          </Card>
          
        </div>
      </div>

      <QRModal 
        isOpen={showQRModal} 
        onClose={() => setShowQRModal(false)} 
      />
    </div>
  );
};

export default Index;